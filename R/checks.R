#' @title
#' Check for possible API user privilege issues

#' @description
#' Check for potential user access privilege issues and provide an appropriate
#' warning message. This can occur when metadata forms/field names do not appear
#' in a database export.
#'
#' @return
#' A helpful error message alerting the user to check their API privileges.
#'
#' @importFrom rlang .data
#' @importFrom dplyr filter select
#' @importFrom tidyr pivot_wider
#'
#' @param db_data The REDCap database output generated by
#' \code{REDCapR::redcap_read_oneshot()$data}
#' @param db_metadata The REDCap metadata output generated by \code{REDCapR::redcap_metadata_read()$data}
#'
#' @keywords internal

check_user_rights <- function(
    db_data,
    db_metadata
) {
  # Similar to link_arms, use pivot wider to create list elements with top
  # level form_name and vector of associated field_names
  missing_db_metadata <- db_metadata %>%
    filter(!.data$field_name_updated %in% names(db_data)) %>%
    select(.data$field_name_updated, .data$form_name) %>%
    pivot_wider(names_from = .data$form_name,
                values_from = .data$field_name_updated,
                values_fn = list)

  # Supply user with warning message(s) displaying missing form name and
  # associated fields
  for (i in seq_len(ncol(missing_db_metadata))) {
    warning(paste0(
      "Form name {", names(missing_db_metadata)[i], "} detected in metadata, but not found in the database export. This can happen when the user privileges are not set to allow exporting that form via the API. The following variables are affected: ",
      paste(unlist(missing_db_metadata[i][[1]]), collapse = ", ")),
      call. = FALSE)
  }
}

#' @title
#' Check for instruments that have both repeating and non-repeating structure
#'
#' @description
#' Check for potential instruments that are given both repeating and
#' nonrepeating structure. \code{REDCapTidieR} does not support database
#' structures built this way.
#'
#' @return
#' A helpful error message alerting the user to existence of a form containing
#' both repeating and non-repeating structure.
#'
#' @param db_data The REDCap database output generated by
#' \code{REDCapR::redcap_read_oneshot()$data}
#'
#' @importFrom rlang .data
#' @importFrom dplyr %>% select mutate case_when
#' @importFrom purrr map2
#'
#' @keywords internal


check_repeat_and_nonrepeat <- function(db_data) {

  # This check function looks for potential repeat/nonrepeat behavior using the
  # steps below:
  # 1) Define standard columns that don't need checking and remove those from
  #    analysis (i.e. "safe columns").
  # 2) Create a dummy column for each remaining column and use case_when to
  #    to assign whether the column demonstrates repeating, nonrepeating, or
  #    indeterminant behavior per row. Indetemrinant would be the case for
  #    data not yet filled out.
  # 3) Use a mapping function to determine if any dummy columns contain both
  #    "repeating" AND "nonrepeating" declarations, if so error out.

  # Step (1)
  safe_cols <- names(db_data)[1:4]

  # Step (2)
  check_data <- db_data %>%
    mutate(
      across(.cols = -all_of(safe_cols),
             .names = "{.col}_repeatingcheck",
             .fns = ~case_when(
               !is.na(.x) & !is.na(redcap_repeat_instrument) ~ "repeating",
               !is.na(.x) & is.na(redcap_repeat_instrument) ~ "nonrepeating",
               TRUE ~ NA_character_
             ))
    )


  # Step (3)
  repeat_nonrepeat_error <- function(check_data, names){

    if ("repeating" %in% check_data &
        "nonrepeating" %in% check_data){
      stop(
        paste0("Instrument detected belonging to an instrument that is both
               repeating and nonrepeating: ",
               gsub(pattern = "_repeatingcheck", replacement = "", x = names)
        )
      )
    }
  }

  purrr::map2(.x = check_data %>% select(ends_with("_repeatingcheck")),
              .y = check_data %>% select(ends_with("_repeatingcheck")) %>% names(),
              .f = ~repeat_nonrepeat_error(.x, .y)
  )

}

#' @title
#' Check that a supplied REDCap database is populated

#' @description
#' Check for potential outputs where metadata is present, but \code{nrow} and
#' \code{ncol} equal `0`. This causes \code{multi_choice_to_labels} to fail, but
#' a helpful error message should be provided.
#'
#' @return
#' A helpful error message alerting the user to check their API privileges.
#'
#' @param db_data The REDCap database output generated by
#' \code{REDCapR::redcap_read_oneshot()$data}
#'
#' @keywords internal

check_redcap_populated <- function(
    db_data
) {
  if (ncol(db_data) == 0) {
    stop(
      paste0("The REDCap API did not return any data. This can happen when there are no data entered or when the access isn't configured to allow data download through the API."
      )
    )
  }
}


#' @title
#' Check that all requested forms are in REDCap project metadata
#'
#' @description
#' Provide an error message when any form names are passed to
#' \code{read_redcap_tidy()} that do not exist in the project metadata.
#'
#' @return
#' An error message listing the requested forms that don't exist
#'
#' @importFrom cli cli_abort
#'
#' @param db_metadata The metadata file read by
#' \code{REDCapR::redcap_metadata_read()}
#' @param forms The character vector of form names passed to
#' \code{read_redcap_tidy()}
#'
#' @keywords internal
check_forms_exist <- function(db_metadata, forms) {
  missing_forms <- setdiff(forms, unique(db_metadata$form_name))

  if (length(missing_forms) > 0) {
    cli_abort(
      c("x" = "Form{?s} {missing_forms} {?does/do} not exist in REDCap project"),
      class = c("form_does_not_exist", "REDCapTidieR_cond")
    )
  }
}
