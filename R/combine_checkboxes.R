#' @title Combine Checkbox Fields into a Single Column
#'
#' @description
#' [combine_checkboxes()] consolidates multiple checkbox fields in a REDCap data
#' tibble into a single column. This transformation simplifies analysis by
#' combining multiple binary columns into a singular and informative labelled
#' factor column.
#'
#' @param supertbl A supertibble generated by [read_redcap()]. Required.
#' @param tbl The `redcap_form_name` of the data tibble to extract. Required.
#' @param cols <[`tidy-select`][tidyr_tidy_select]> Checbox columns to combine to
#' single column. Required.
#' @param values_to A string specifying the name of the column to combine checkbox
#' values under. Required.
#' @param multi_value_label A string specifying the value to be used when multiple
#' checkbox fields are selected. Default "Multiple".
#' @param values_fill Value to use when no checkboxes are selected. Default `NA`.
#' @param raw_or_label Either 'raw' or 'label' to specify whether to use raw coded
#' values or labels for the options. Default 'label'.
#' @param keep Logical indicating whether to keep the original checkbox fields in
#' the output. Default `TRUE`.
#'
#' @return A modified supertibble.
#'
#' @examples
#' \dontrun{
#' supertbl <- read_redcap(redcap_uri, token)
#' combined_tbl <- combine_checkboxes(
#'   supertbl = supertbl,
#'   tbl = "demographics",
#'   cols = starts_with("race"),
#'   values_to = "race_combined",
#'   multi_value_label = "Multiple",
#'   values_fill = NA
#' )
#' }
#'
#' @export

combine_checkboxes <- function(supertbl,
                               tbl,
                               cols,
                               values_to,
                               multi_value_label = "Multiple",
                               values_fill = NA,
                               raw_or_label = "label",
                               keep = TRUE) {
  # Check args ---
  check_arg_is_supertbl(supertbl, req_cols = c("redcap_data", "redcap_metadata"))
  check_arg_is_character(tbl, len = 1, any.missing = FALSE)
  check_arg_is_character(values_to, any.missing = FALSE)
  check_arg_is_character(multi_value_label, len = 1, any.missing = TRUE)
  check_arg_is_character(values_fill, len = 1, any.missing = TRUE)
  check_arg_choices(raw_or_label, choices = c("label", "raw"))
  check_arg_is_logical(keep, len = 1, any.missing = FALSE)

  # Extract tbl from supertbl
  data_tbl <- supertbl %>%
    extract_tibble(tbl)

  # Save user cols to quosure
  cols_exp <- enquo(cols)

  # Evaluate the cols expression to get the selected column names
  selected_cols <- names(eval_select(cols_exp, data = data_tbl))
  check_fields_exist(fields = selected_cols, expr = cols_exp) # Check supplied fields exist

  # Extract the prefix of each selected column
  prefixes <- sub("___.*", "", selected_cols)

  # Split the selected columns based on their prefixes
  col_groups <- split(selected_cols, prefixes)
  check_values_to_length(col_groups, values_to) # Check values_to columns match length of fields

  # Get metadata reference table, check that chosen fields are checkboxes
  metadata_tbl <- supertbl$redcap_metadata[supertbl$redcap_form_name == tbl][[1]]
  metadata_ref <- get_metadata_ref(metadata_tbl, selected_cols)

  # Define values_to as the count of TRUEs/1s for the given checkbox field
  # Assign TRUE if multiple selections made, and FALSE if one or zero made
  data_tbl_mod <- data_tbl

  for (i in seq_along(values_to)) {
    data_tbl_mod <- data_tbl_mod %>%
      mutate(
        !!values_to[i] := case_when(
          rowSums(select(., col_groups[[i]])) > 1 ~ TRUE,
          .default = FALSE
        )
      )
  }

  # Replace TRUEs/1s with raw/label values from metadata
  data_tbl_mod <- data_tbl_mod %>%
    mutate(
      across(
        selected_cols,
        ~ replace_true(.x,
          cur_column(),
          metadata = metadata_ref,
          raw_or_label = raw_or_label
        )
      ),
      across(selected_cols, as.character) # enforce to character strings
    )

  for (i in seq_along(values_to)) {
    metadata_overwrite <- metadata_ref %>%
      filter(.data$field_name %in% col_groups[[i]]) %>%
      pull(raw_or_label)

    data_tbl_mod <- data_tbl_mod %>%
      mutate(
        !!values_to[i] := ifelse(!!sym(values_to[i]),
          multi_value_label,
          coalesce(!!!syms(col_groups[[i]]))
        ),
        !!values_to[i] := ifelse(is.na(!!sym(values_to[i])),
          values_fill,
          !!sym(values_to[i])
        )
      ) %>%
      mutate(
        !!values_to[i] := factor(!!sym(values_to[i]),
          levels = c(metadata_overwrite, multi_value_label, values_fill)
        )
      )
  }

  final_tbl <- bind_cols(
    data_tbl,
    data_tbl_mod %>% select(!!values_to)
  )

  # Keep or remove original multi columns
  if (!keep) {
    final_tbl <- final_tbl %>%
      select(-selected_cols)
  }

  # Update the supertbl data tibble
  supertbl$redcap_data[supertbl$redcap_form_name == tbl][[1]] <- final_tbl

  supertbl
}

#' @title Utility function for getting metadata raw and label values for checkboxes
#'
#' @param metadata_tbl A metadata tibble from the supertibble generated by [read_redcap()].
#' @param selected_cols Character string vector of field names for checkbox combination
#'
#' @returns a tibble
#'
#' @keywords internal
get_metadata_ref <- function(metadata_tbl,
                             selected_cols) {
  # Create a metadata reference table linking field name to raw and label values
  out <- metadata_tbl %>%
    filter(.data$field_name %in% selected_cols) %>%
    mutate(
      original_field = sub("___.*$", "", .data$field_name)
    )

  # Make sure selection is checkbox metadata field type
  check_fields_are_checkboxes(out)

  # Bind raw/label values per original field grouping
  parsed_vals <- tibble()

  for (i in seq_along(unique(out$original_field))) {
    index <- unique(out$original_field)[i]
    out_filtered <- out %>% filter(.data$original_field == index)

    parsed_vals <- rbind(parsed_vals, parse_labels(first(out_filtered$select_choices_or_calculations)))
  }

  bind_cols(out, parsed_vals) %>%
    select(.data$field_name, .data$raw, .data$label, .data$original_field) %>%
    relocate(.data$original_field, .after = .data$field_name)
}

#' @noRd
#' @keywords internal
replace_true <- function(col, col_name, metadata, raw_or_label) {
  # Replace TRUEs/1s with the appropriate raw or label value from the metadata
  replacement <- metadata %>%
    filter(.data$field_name == col_name) %>%
    pull(raw_or_label)
  col <- ifelse(col == TRUE, replacement, NA) # col == TRUE works for raw or label because TRUE == 1 & 1 == TRUE
  # Convert non-TRUEs to NA, since values can be either "FALSE" or "0" for unchecked values
  return(col)
}
