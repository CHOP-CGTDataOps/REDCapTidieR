#' @title Combine Checkbox Fields into a Single Column
#'
#' @description
#' [combine_checkboxes()] consolidates multiple checkbox fields in a REDCap data
#' tibble into a single column. This transformation simplifies analysis by
#' combining multiple binary columns into a singular and informative labelled
#' factor column.
#'
#' @param supertbl A supertibble generated by [read_redcap()]. Required.
#' @param tbl The `redcap_form_name` of the data tibble to extract. Required.
#' @param cols <[`tidy-select`][tidyr_tidy_select]> Checbox columns to combine to
#' single column. Required.
#' @param values_to A string specifying the name of the column to combine checkbox
#' values under. Required.
#' @param multi_value_label A string specifying the value to be used when multiple
#' checkbox fields are selected. Default "Multiple".
#' @param values_fill Value to use when no checkboxes are selected. Default `NA`.
#' @param raw_or_label Either 'raw' or 'label' to specify whether to use raw coded
#' values or labels for the options. Default 'label'.
#' @param keep Logical indicating whether to keep the original checkbox fields in
#' the output. Default `TRUE`.
#'
#' @return A modified supertibble.
#'
#' @examples
#' \dontrun{
#' supertbl <- read_redcap(redcap_uri, token)
#' combined_tbl <- combine_checkboxes(
#'   supertbl = supertbl,
#'   tbl = "demographics",
#'   cols = starts_with("race"),
#'   values_to = "race_combined",
#'   multi_value_label = "Multiple",
#'   values_fill = NA
#' )
#' }
#'
#' @export

combine_checkboxes <- function(supertbl,
                               tbl,
                               cols,
                               values_to,
                               multi_value_label = "Multiple",
                               values_fill = NA,
                               raw_or_label = "label",
                               keep = TRUE) {

  # Check args ---
  check_arg_is_supertbl(supertbl, req_cols = c("redcap_data", "redcap_metadata"))
  check_arg_is_character(tbl, len = 1, any.missing = FALSE)
  check_arg_is_character(values_to, len = 1, any.missing = FALSE)
  check_arg_is_character(multi_value_label, len = 1, any.missing = TRUE)
  check_arg_is_character(values_fill, len = 1, any.missing = TRUE)
  check_arg_choices(raw_or_label, choices = c("label", "raw"))
  check_arg_is_logical(keep, len = 1, any.missing = FALSE)

  # Save user cols to enquosure
  cols_exp <- enquo(cols)

  # Extract tbl from supertbl
  data_tbl <- supertbl %>%
    extract_tibble(tbl)

  # Get field names from cols_exp, check that fields exist
  field_names <- names(eval_select(cols_exp, data = data_tbl))
  check_fields_exist(fields = field_names, expr = cols_exp)

  # Identify record_id field
  record_id_field <- get_record_id_field(supertbl$redcap_data[[1]])

  # Define values_to as the count of TRUEs/1s for the given checkbox field
  # Assign TRUE if multiple selections made, and FALSE if one or zero made
  data_tbl_mod <- data_tbl %>%
    mutate(
      !!values_to := case_when(
        rowSums(select(., eval_tidy(cols_exp))) > 1 ~ TRUE,
        TRUE ~ FALSE
      )
    )

  # Get metadata reference table, check that chosen fields are checkboxes
  metadata <- get_metadata_ref(data_tbl_mod, supertbl, tbl, field_names)

  # Replace TRUEs/1s with raw/label values from metadata
  data_tbl_mod <- data_tbl_mod %>%
    mutate(across(
      field_names,
      ~ replace_true(.x,
                     cur_column(),
                     metadata = metadata,
                     raw_or_label = raw_or_label
      )
    ))


  # Convert values_to from TRUE/FALSE to multi_value_label or identified single val
  data_tbl_mod <- data_tbl_mod %>%
    mutate(
      across(field_names, as.character), # enforce to character strings
      across(!!values_to, ~ as.character(.))
    ) %>%
    mutate(
      !!values_to := ifelse(!!sym(values_to) == "TRUE",
                            multi_value_label,
                            coalesce(!!!syms(field_names))
      ),
      !!values_to := ifelse(is.na(!!sym(values_to)),
                            values_fill,
                            !!sym(values_to))
    ) %>%
    mutate(
      !!values_to := factor(!!sym(values_to),
                            levels = c(metadata[[raw_or_label]], multi_value_label, values_fill))
    )

  final_tbl <- bind_cols(data_tbl,
                         data_tbl_mod %>% select(!!values_to))

  # Keep or remove original multi columns
  if (!keep) {
    final_tbl <- final_tbl %>%
      select(-field_names)
  }

  # Update the supertbl data tibble
  supertbl$redcap_data[supertbl$redcap_form_name == tbl][[1]] <- final_tbl

  supertbl
}

#' @title Utility function for getting metadata raw and label values for checkboxes
#'
#' @param data a data tibble
#' @param supertbl A supertibble generated by [read_redcap()].
#' @param tbl The name of the REDCap form (instrument) containing the checkbox
#' fields.
#' @param field_names Character string vector of field names for checkbox combination
#'
#' @returns a tibble
#'
#' @keywords internal
get_metadata_ref <- function(data,
                             supertbl,
                             tbl,
                             field_names) {

  # Create a metadata reference table linking field name to raw and label values
  out <- supertbl$redcap_metadata[supertbl$redcap_form_name == tbl][[1]] %>%
    filter(.data$field_name %in% field_names) %>%
    # TODO: original_field a temporary placeholder for future multi-field and mapping dev
    mutate(
      original_field = sub("___.*$", "", .data$field_name)
    )

  # Make sure selection is checkbox metadata field type
  check_fields_are_checkboxes(out)

  # TODO: Make more robust for multi-field and mapping, using original_field above
  parsed_vals <- parse_labels(first(out$select_choices_or_calculations))

  bind_cols(out, parsed_vals) %>%
    select(.data$field_name, .data$raw, .data$label)
}

#' @noRd
#' @keywords internal
replace_true <- function(col, col_name, metadata, raw_or_label) {
  # Replace TRUEs/1s with the appropriate raw or label value from the metadata
  replacement <- metadata %>%
    filter(.data$field_name == col_name) %>%
    pull(raw_or_label)
  col <- ifelse(col == TRUE, replacement, NA) # col == TRUE works for raw or label because TRUE == 1 & 1 == TRUE
  # Convert non-TRUEs to NA, since values can be either "FALSE" or "0" for unchecked values
  return(col)
}
