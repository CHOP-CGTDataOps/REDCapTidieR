#' @title Reduce Multiple Choice Checkbox Fields to Single Column
#'
#' @description
#' Convert checkbox fields in a data tibble, represented as many columns, into
#' a single column with values.
#'
#' @param supertbl A supertibble generated by [read_redcap()]. Required.
#' @param tbl The `redcap_form_name` of the data tibble under analysis. Required.
#' @param cols One or more columns to specify the checkbox field names for conversion. Required.
#' @param cols_to A string for the name of the column to consolidate values under. Required.
#' @param multi_to A string to specify the placeholder value for rows where multiple
#' checkboxes are selected. Default "Multiple".
#' @param raw_or_label A string (either 'raw' or 'label') that specifies whether
#' to export the raw coded values or the labels for the options of categorical
#' fields. Default is 'label'.
#'
#' @returns A `tibble`.
#'
#' @export

reduce_multi_to_single_column <- function(supertbl,
                                          tbl,
                                          cols,
                                          cols_to,
                                          multi_val = "Multiple",
                                          raw_or_label = "label") {
  # Save user cols to enquosure
  cols_exp <- enquo(cols)

  # Extract tbl from supertbl
  data_tbl <- supertbl %>%
    extract_tibble(tbl)

  # Assume the first instrument in the metadata contains IDs
  # REDCap enforces this constraints, we reflect this in read_redcap -> get_field_to_drop
  record_id_field <- supertbl$redcap_metadata[supertbl$redcap_form_name == tbl][[1]]$field_name[1]

  # Combine record identifier with remaining possible project identifiers
  project_identifiers <- c(record_id_field, "redcap_form_instance", "redcap_form_name", "redcap_event", "redcap_event_instance")

  out <- data_tbl %>%
    select(any_of(project_identifiers), !!!eval_select(cols_exp, data_tbl))

  # Define field names as remaining vars defined by the user that aren't identifiers
  field_names <- names(out)[!names(out) %in% project_identifiers]

  # Define cols_to as the count of TRUEs/1s for the given checkbox field
  # Assign TRUE if multiple selections made, and FALSE if one or zero made
  out <- out %>%
    mutate(
      !!cols_to := case_when(rowSums(select(., eval_tidy(cols_exp))) > 1 ~ TRUE,
                       TRUE ~ FALSE)

    )

  # Get metadata reference table
  metadata <- get_metadata_ref(out, supertbl, tbl, project_identifiers)

  # Replace TRUEs/1s with raw/label values from metadata
  out <- out %>%
    mutate(across(-c(any_of(project_identifiers), !!cols_to), ~ replace_true(.x,
                                                                    cur_column(),
                                                                    metadata = metadata,
                                                                    raw_or_label = raw_or_label)))


  # Convert cols_to from TRUE/FALSE to multi_val or identified single val
  out <- out %>%
    mutate(across(field_names, as.character), # enforce to character strings
           across(!!cols_to, ~as.character(.))) %>%
    rowwise() %>%
    mutate(
      !!cols_to := ifelse(!!sym(cols_to) == "TRUE",
                          multi_val,
                          coalesce(!!!syms(field_names)))
    ) %>%
    ungroup() %>%
    select(any_of(project_identifiers), !!cols_to) %>%
    mutate(
      !!cols_to := factor(!!sym(cols_to), levels = c(metadata[[raw_or_label]], multi_val))
    )

  # Join back onto original data tbl
  out %>%
    right_join(data_tbl, by = intersect(project_identifiers, names(out))) %>%
    relocate(!!cols_to, .after = everything())
}

#' @noRd
#' @keywords internal
get_metadata_ref <- function(data, supertbl, tbl, project_identifiers) {
  out <- supertbl$redcap_metadata[supertbl$redcap_form_name == tbl][[1]] %>%
    filter(field_name %in% names(data)[!names(data) %in% project_identifiers]) %>%
    select(field_name, select_choices_or_calculations) %>%
    mutate(
      original_field = sub("___.*$", "", field_name)
    ) %>%
    mutate(pairs = strsplit(select_choices_or_calculations, " \\| "),
           label_value = NA)

  for (i in seq(nrow(out))) {
    out$label_value[i] <- out$pairs[[i]][i]
  }

  out %>%
    separate_wider_delim(label_value, delim = ", ", names = c("raw", "label")) %>%
    select(field_name, raw, label)
}

#' @noRd
#' @keywords internal
replace_true <- function(col, col_name, metadata, raw_or_label) {
  replacement <- metadata %>% filter(field_name == col_name) %>% pull(raw_or_label)
  col <- ifelse(col == TRUE, replacement, NA) # col == TRUE works for raw or label because TRUE == 1 and 1 == TRUE
  # Convert non-TRUEs to NA, since values can be either "FALSE" or "0" for unchecked values
  return(col)
}
