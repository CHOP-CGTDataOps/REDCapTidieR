#' @title Reduce Multiple Choice Checkbox Fields to Single Column
#'
#' @description
#' Convert checkbox fields in a data tibble, represented as many columns, into
#' a single column with values.
#'
#' @param supertbl A supertibble generated by [read_redcap()]. Required.
#' @param tbl The `redcap_form_name` of the data tibble under analysis. Required.
#' @param cols One or more columns to specify the checkbox field names for conversion. Required.
#' @param cols_to A string for the name of the column to consolidate values under. Required.
#' @param multi_to A string to specify the placeholder value for rows where multiple
#' checkboxes are selected. Default "Multiple".
#' @param no_val A string indicating a value to use when no checkboxes are selected.
#' Default `NA`.
#' @param raw_or_label A string (either 'raw' or 'label') that specifies whether
#' to export the raw coded values or the labels for the options of categorical
#' fields. Default is 'label'.
#' @param keep Whether or not to keep the original fields in the output. Default `TRUE`.
#'
#' @returns A `tibble`.
#'
#' @export

reduce_multi_to_single_column <- function(supertbl,
                                          tbl,
                                          cols,
                                          cols_to,
                                          multi_val = "Multiple",
                                          no_val = NA,
                                          raw_or_label = "label",
                                          keep = TRUE) {

  # Save user cols to enquosure
  cols_exp <- enquo(cols)

  # Extract tbl from supertbl
  data_tbl <- supertbl %>%
    extract_tibble(tbl)

  # Get field names from cols_exp
  field_names <- names(eval_select(cols_exp, data = data_tbl))

  # Assume the first instrument in the metadata contains IDs
  # REDCap enforces this constraints, we reflect this in read_redcap -> get_field_to_drop
  record_id_field <- supertbl$redcap_metadata[supertbl$redcap_form_name == tbl][[1]]$field_name[1]

  # Combine record identifier with remaining possible project identifiers
  instrument_identifiers <- c(record_id_field, "redcap_form_instance", "redcap_form_name", "redcap_event", "redcap_event_instance")

  # Define cols_to as the count of TRUEs/1s for the given checkbox field
  # Assign TRUE if multiple selections made, and FALSE if one or zero made
  out <- data_tbl %>%
    select(any_of(instrument_identifiers), !!!eval_select(cols_exp, data_tbl)) %>%
    mutate(
      !!cols_to := case_when(rowSums(select(., eval_tidy(cols_exp))) > 1 ~ TRUE,
                       TRUE ~ FALSE)

    )

  # Get metadata reference table
  metadata <- get_metadata_ref(out, supertbl, tbl, instrument_identifiers)

  # Replace TRUEs/1s with raw/label values from metadata
  out <- out %>%
    mutate(across(-c(any_of(instrument_identifiers), !!cols_to), ~ replace_true(.x,
                                                                    cur_column(),
                                                                    metadata = metadata,
                                                                    raw_or_label = raw_or_label)))


  # Convert cols_to from TRUE/FALSE to multi_val or identified single val
  out <- out %>%
    mutate(across(field_names, as.character), # enforce to character strings
           across(!!cols_to, ~as.character(.))) %>%
    rowwise() %>%
    mutate(
      !!cols_to := ifelse(!!sym(cols_to) == "TRUE",
                          multi_val,
                          coalesce(!!!syms(field_names))),
      !!cols_to := ifelse(is.na(!!sym(cols_to)), no_val, !!sym(cols_to))
    ) %>%
    ungroup() %>%
    select(any_of(instrument_identifiers), !!cols_to) %>%
    mutate(
      !!cols_to := factor(!!sym(cols_to), levels = c(metadata[[raw_or_label]], multi_val, no_val))
    )

  # Join back onto original data tbl
  if (keep) {
    out %>%
      right_join(data_tbl, by = intersect(instrument_identifiers, names(out))) %>%
      relocate(!!cols_to, .after = everything())
  } else {
    out
  }
}

#' @noRd
#' @keywords internal
get_metadata_ref <- function(data, supertbl, tbl, instrument_identifiers) {

  # Create a metadata reference table linking field name to raw and label values
  out <- supertbl$redcap_metadata[supertbl$redcap_form_name == tbl][[1]] %>%
    filter(field_name %in% names(data)[!names(data) %in% instrument_identifiers]) %>%
    select(field_name, select_choices_or_calculations) %>%
    mutate(
      original_field = sub("___.*$", "", field_name)
    ) %>%
    mutate(pairs = strsplit(select_choices_or_calculations, " \\| "),
           label_value = NA)

  for (i in seq(nrow(out))) {
    out$label_value[i] <- out$pairs[[i]][i]
  }

  out %>%
    separate_wider_delim(label_value, delim = ", ", names = c("raw", "label")) %>%
    select(field_name, raw, label)

}

#' @noRd
#' @keywords internal
replace_true <- function(col, col_name, metadata, raw_or_label) {

  # Replace TRUEs/1s with the appropriate raw or label value from the metadata
  replacement <- metadata %>% filter(field_name == col_name) %>% pull(raw_or_label)
  col <- ifelse(col == TRUE, replacement, NA) # col == TRUE works for raw or label because TRUE == 1 and 1 == TRUE
  # Convert non-TRUEs to NA, since values can be either "FALSE" or "0" for unchecked values
  return(col)
}
