#' @title Combine Checkbox Fields into a Single Column
#'
#' @description
#' [combine_checkboxes()] consolidates multiple checkbox fields in a REDCap data
#' tibble into a single column. This transformation simplifies analysis by
#' combining multiple binary columns into a singular and informative labelled
#' factor column.
#'
#' @param supertbl A supertibble generated by [read_redcap()]. Required.
#' @param form_name The name of the REDCap form (instrument) containing the checkbox
#' fields. Required.
#' @param cols <[`tidy-select`][tidyr_tidy_select]> Checbox columns to combine to
#' single column. Required.
#' @param values_to A string specifying the name of the column to combine checkbox
#' values under. Required.
#' @param multi_value_label A string specifying the value to be used when multiple
#' checkbox fields are selected. Default "Multiple".
#' @param values_fill Value to use when no checkboxes are selected. Default `NA`.
#' @param raw_or_label Either 'raw' or 'label' to specify whether to use raw coded
#' values or labels for the options. Default 'label'.
#' @param keep Logical indicating whether to keep the original checkbox fields in
#' the output. Default `TRUE`.
#'
#' @return A modified supertibble.
#'
#' @examples
#' \dontrun{
#' supertbl <- read_redcap(redcap_uri, token)
#' combined_tbl <- combine_checkboxes(
#'   supertbl = supertbl,
#'   form_name = "demographics",
#'   cols = starts_with("race"),
#'   values_to = "race_combined",
#'   multi_value_label = "Multiple",
#'   values_fill = NA
#' )
#' }
#'
#' @export

combine_checkboxes <- function(supertbl,
                               form_name,
                               cols,
                               values_to,
                               multi_value_label = "Multiple",
                               values_fill = NA,
                               raw_or_label = "label",
                               keep = TRUE) {
  # Save user cols to enquosure
  cols_exp <- enquo(cols)

  # Extract form_name from supertbl
  data_tbl <- supertbl %>%
    extract_tibble(form_name)

  # Get field names from cols_exp, check that fields exist
  field_names <- names(eval_select(cols_exp, data = data_tbl))
  check_fields_exist(fields = field_names, expr = cols_exp)

  # Assume the first instrument in the metadata contains IDs
  # REDCap enforces this constraints, we reflect this in read_redcap -> get_field_to_drop
  record_id_field <- supertbl$redcap_metadata[supertbl$redcap_form_name == form_name][[1]]$field_name[1]

  # Combine record identifier with remaining possible project identifiers
  instrument_identifiers <- c(
    record_id_field,
    "redcap_form_instance",
    "redcap_form_name",
    "redcap_event",
    "redcap_event_instance"
  )

  # Define values_to as the count of TRUEs/1s for the given checkbox field
  # Assign TRUE if multiple selections made, and FALSE if one or zero made
  data_tbl_mod <- data_tbl %>%
    select(any_of(instrument_identifiers), !!!eval_select(cols_exp, data_tbl)) %>%
    mutate(
      !!values_to := case_when(
        rowSums(select(., eval_tidy(cols_exp))) > 1 ~ TRUE,
        TRUE ~ FALSE
      )
    )

  # Get metadata reference table, check that chosen fields are checkboxes
  metadata <- get_metadata_ref(data_tbl_mod, supertbl, form_name, instrument_identifiers)

  # Replace TRUEs/1s with raw/label values from metadata
  data_tbl_mod <- data_tbl_mod %>%
    mutate(across(
      -c(any_of(instrument_identifiers), !!values_to),
      ~ replace_true(.x,
        cur_column(),
        metadata = metadata,
        raw_or_label = raw_or_label
      )
    ))

  # Convert values_to from TRUE/FALSE to multi_value_label or identified single val
  data_tbl_mod <- data_tbl_mod %>%
    mutate(
      across(field_names, as.character), # enforce to character strings
      across(!!values_to, ~ as.character(.))
    ) %>%
    rowwise() %>%
    mutate(
      !!values_to := ifelse(!!sym(values_to) == "TRUE",
        multi_value_label,
        coalesce(!!!syms(field_names))
      ),
      !!values_to := ifelse(is.na(!!sym(values_to)), values_fill, !!sym(values_to))
    ) %>%
    ungroup() %>%
    select(any_of(instrument_identifiers), !!values_to) %>%
    mutate(
      !!values_to := factor(!!sym(values_to), levels = c(metadata[[raw_or_label]], multi_value_label, values_fill))
    )

  # Join back onto original data form_name
  data_tbl_mod <- data_tbl_mod %>%
    right_join(data_tbl, by = intersect(instrument_identifiers, names(data_tbl_mod))) %>%
    relocate(!!values_to, .after = everything())

  # Keep or remove original multi columns
  if (!keep) {
    data_tbl_mod <- data_tbl_mod %>%
      select(-field_names)
  }

  # Update the supertbl data tibble
  supertbl$redcap_data[supertbl$redcap_form_name == form_name][[1]] <- data_tbl_mod

  supertbl
}

#' @title Utility function for getting metadata raw and label values for checkboxes
#'
#' @param data a data tibble
#' @param supertbl A supertibble generated by [read_redcap()].
#' @param form_name The name of the REDCap form (instrument) containing the checkbox
#' fields.
#' @param instrument_identifiers Character string vector of project record identifier vars
#'
#' @returns a tibble
#'
#' @keywords internal
get_metadata_ref <- function(data,
                             supertbl,
                             form_name,
                             instrument_identifiers) {
  # Create a metadata reference table linking field name to raw and label values
  out <- supertbl$redcap_metadata[supertbl$redcap_form_name == form_name][[1]] %>%
    filter(.data$field_name %in% names(data)[!names(data) %in% instrument_identifiers])

  # Make sure selection is checkbox metadata field type
  check_fields_are_checkboxes(out)

  out <- out %>%
    select(.data$field_name, .data$select_choices_or_calculations) %>%
    mutate(
      original_field = sub("___.*$", "", .data$field_name)
    ) %>%
    mutate(
      pairs = strsplit(.data$select_choices_or_calculations, " \\| "),
      label_value = NA,
      label_value = purrr::map2_chr(pairs, row_number(), \(.x, .y) .x[.y])
    )

  out %>%
    separate_wider_delim(.data$label_value, delim = ", ", names = c("raw", "label")) %>%
    select(.data$field_name, .data$raw, .data$label)
}

#' @noRd
#' @keywords internal
replace_true <- function(col, col_name, metadata, raw_or_label) {
  # Replace TRUEs/1s with the appropriate raw or label value from the metadata
  replacement <- metadata %>%
    filter(.data$field_name == col_name) %>%
    pull(raw_or_label)
  col <- ifelse(col == TRUE, replacement, NA) # col == TRUE works for raw or label because TRUE == 1 & 1 == TRUE
  # Convert non-TRUEs to NA, since values can be either "FALSE" or "0" for unchecked values
  return(col)
}
